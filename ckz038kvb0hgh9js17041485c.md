## TypeScript - ƒë·ªãnh nghƒ©a ki·ªÉu cho index c·ªßa Object - indexable-types hay c√°ch g·ªçi kh√°c l√† index signature üñäÔ∏è

Trong b√†o vi·∫øt s·ª≠ d·ª•ng source-code TypeScript, do ƒë√≥ c√°ch nhanh nh·∫•t c√≥ th·ªÉ ch·∫°y th·ª≠ ch√∫ng l√† copy v√† d√°n v√†o web [typescript playground](https://www.typescriptlang.org/play).

## T·∫°i sao c·∫ßn n√≥?

Ta xem v√≠ d·ª• khi mu·ªën l∆∞u tr·ªØ data v·ªÅ t·∫ßn su·∫•t ƒë·ªçc s√°ch c·ªßa b·∫£n th√¢n theo ng√†y v√†o 1 object ƒë·ªÉ ti·ªán truy c·∫≠p. V√≠ d·ª• h√¥m nay *2022-01-29* m√¨nh ƒë·ªçc s√°ch t·ª©c l√†:

```ts
const readingBookDates: any = {};
readingBookDates['2022-01-29'] = true;
```

N·∫øu ta kh√¥ng s·ª≠ d·ª•ng type l√† `any` nh∆∞ tr√™n th√¨ s·∫Ω c√≥ l·ªói:

> Element implicitly has an 'any' type because expression of type '"2022-01-29"' can't be used to index type '{}'. Property '2022-01-29' does not exist on type '{}'.(7053)

Li·ªáu c√≥ c√°ch n√†o kh√¥ng ph·∫£i `any`, ƒë·ªÉ tr√°nh c√°c tai n·∫°n khi g√°n nh·∫ßm ki·ªÉu cho gi√° tr·ªã cho index - *2022-01-29* cho 1 object ƒë·ªông nh∆∞ th·∫ø n√†y? V√≠ d·ª• ta v·∫´n c√≥ th·ªÉ vi·∫øt nh∆∞ sau m√† kh√¥ng ph√°t hi·ªán l·ªói v·ªÅ ki·ªÉu:

```ts
readingBookDates['2022-01-29'] = false;
readingBookDates['2022-01-29'] = 1;
readingBookDates[1] = 0;
```

L√∫c n√†y ta mu·ªën t·∫°o ra 1 object c√≥ c√°c properties hay index l√† 1 lo·∫°i string unique m√¥ t·∫£ th√¥ng tin nƒÉm th√°ng ng√†y, tuy nhi√™n nh·ªØng index hay properties l√† ƒë·ªông, kh√¥ng ƒë·ªÉ set c·ª©ng nh∆∞ object type, interface th√¥ng th∆∞·ªùng.

Nh·ªØng b√†i to√°n v·ªÅ mapping gi·ªØa key - value ki·ªÉu t·ª´ ƒëi·ªÉn th∆∞·ªùng s·∫Ω g·∫∑p nh·ªØng ki·ªÉu nh∆∞ th·∫ø n√†y. ƒê√≥ l√† l√∫c ta c·∫ßn ƒë·∫øn indexable-types.

## C√°ch d√πng c∆° b·∫£n

Thay v√¨ ƒë·ªÉ ki·ªÉu any, ta s·∫Ω ƒë·ªãnh nghƒ©a ki·ªÉu nh∆∞ sau:

```ts
const readingBookDates: { [key: string]: true} = {};
readingBookDates['2022-01-29'] = true;
```

Nh·ªØng c√¢u g√°n gi√° tr·ªã nh∆∞ sau s·∫Ω b√°o l·ªói h·∫øt:

```ts
readingBookDates['2022-01-29'] = false;
readingBookDates['2022-01-29'] = 1;
readingBookDates[1] = 0;
```

Gi·ªù ta ch·ªâ c√≥ th·ªÉ g√°n cho nh·ªØng index ƒë√∫ng chu·∫©n l√† `string` v·ªõi gi√° tr·ªã ch·ªâ c√≥ th·ªÉ l√† `true`.

![surprised](https://media.giphy.com/media/QUENDfi6DEMLzQ0CKt/giphy.gif)

C√∫ ph√°p l√† ngo·∫∑c vu√¥ng `[]` bao ngo√†i, `key` ƒë·∫°i di·ªán cho index, ti·∫øp theo l√† ki·ªÉu c·ªßa n√≥. C·∫£ c·ª•m `[]` t∆∞∆°ng ƒë∆∞∆°ng v·ªõi 1 thu·ªôc t√≠nh c·ªßa ki·ªÉu th√¥ng th∆∞·ªùng.

Ta ho√†n to√†n c√≥ th·ªÉ thay th·∫ø t√™n g·ªçi ƒë·∫°i di·ªán `key` th√†nh b·∫•t k·ª≥ t·ª´ kh√≥a n√†o m√† ta mu·ªën. Th·∫≠t v·∫≠y:

```ts
const readingBookDates: { [index: string]: true} = {};
readingBookDates['2022-01-29'] = true;
```

T√¥i th√¨ hay d√πng `key` v√¨ n√≥ d·ªÖ hi·ªÉu v√† tr√™n internet hay th·∫•y t·ª´ kh√≥a ƒë√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng.

Ta c≈©ng c√≥ th·ªÉ s·ª≠ d·ª•ng n√≥ ƒë·ªÉ ƒë·ªãnh nghƒ©a ki·ªÉu cho 1 d√£y ch·ªâ c√≥ th·ªÉ l√† c√°c c√°i t√™n:

```ts
interface StringArray {
  [index: number]: string;
}
 
let myArray: StringArray;
myArray = ["Bob", "Fred"];
 
let myStr: string = myArray[0];
```

V√¨ b·∫£n ch·∫•t array c≈©ng l√† 1 object ƒë·∫∑c bi·ªát v·ªõi index l√† ki·ªÉu s·ªë m√†.

## C√°c ch√∫ √Ω khi s·ª≠ d·ª•ng

ƒê·ªÉ d·ªÖ ph√¢n bi·ªát gi·ªØa ki·ªÉu c·ªßa index signatures (`[key: string]` - l√† c√°i string n√†y n√†y) v·ªõi ki·ªÉu c·ªßa data ƒë∆∞·ª£c mapping t·ªõi (`[key: string]: number` - l√† c√°i number n√†y n√†y), ta s·∫Ω ch√∫ng l·∫ßn l∆∞·ª£t l√† *ki·ªÉu index* v√† *ki·ªÉu tr·∫£ v·ªÅ*.

### C√°c ki·ªÉu index

Kh√¥ng ch·ªâ c√≥ *string* v√† *number*, ta c√≥ t·∫•t c·∫£ 4 ki·ªÉu index:

- string
- number
- symbol
- template strings

·ªû b√†i n√†y m√¨nh s·∫Ω kh√¥ng ƒëi s√¢u v√†o *symbol* v√† *template strings*.

V√≠ d·ª• v·ªÅ d√πng nhi·ªÅu lo·∫°i ki·ªÉu index cho c√πng 1 interface:

```ts
interface Animal {
  name: string;
}
 
interface Dog extends Animal {
  breed: string;
}

interface Okay {
  [x: number]: Dog;
  [x: string]: Animal;
}
```

Tuy nhi√™n, ch√∫ √Ω l√† do ki·ªÉu *number* th·ª±c ch·∫•t ƒë∆∞·ª£c JS convert sang *string* n√™n b·∫Øt bu·ªôc *ki·ªÉu tr·∫£ v·ªÅ* c·ªßa *number* ph·∫£i l√† t·∫≠p con c·ªßa *ki·ªÉu tr·∫£ v·ªÅ* c·ªßa *string*.

H∆°i ph·ª©c t·∫°p nh·ªâ, theo v√≠ d·ª• tr√™n th√¨:

1. *t·∫≠p cha* (string index) ch·ª©a *t·∫≠p con* (number index)
2. *t·∫≠p cha* (Animal) ch·ª©a *t·∫≠p con* (Dog)

(1) v√† (2) ph·∫£i ƒëi ƒë√¥i v·ªõi nhau.

Ng∆∞·ª£c l·∫°i th√¨ s·∫Ω b√°o l·ªói:

```ts
interface NotOkay {
  [x: number]: Animal; // error
  [x: string]: Dog;
}
```

![thinking](https://media.giphy.com/media/3o7TKTDn976rzVgky4/giphy.gif)

### K·∫øt h·ª£p v·ªõi c√°c index c√≥ t√™n ri√™ng th√¥ng th∆∞·ªùng

```ts
interface NumberDictionary {
  [index: string]: number;
 
  length: number; // ok, length is a number
  name: string; // error, the type of 'name' is not a subtype of the indexer
}
```

T∆∞∆°ng t·ª± logic t·∫≠p con lo·∫±ng ngo·∫±ng ph·∫ßn tr√™n, n·∫øu ƒë·ªãnh index c√≥ t√™n ri√™ng th√¥ng th∆∞·ªùng nh∆∞ *length*, *name* th√¨ ta kh√¥ng th·ªÉ set ki·ªÉu string cho *name* v√† set ƒë∆∞·ª£c *number* cho *length* v√¨:

1. *t·∫≠p cha* (string index) ch·ª©a *t·∫≠p con* (length - ch·ªâ l√† 1 string)
2. *t·∫≠p cha* (number) ch·ª©a *t·∫≠p con* (number) (:D)

T·∫°o ra t·∫≠p cha c·ªßa number v√† string ƒë√≥ l√† ph√©p *ho·∫∑c*: `number | string` th√¨ vi·∫øt nh∆∞ d∆∞·ªõi ƒë√¢y ok:

```ts
interface NumberOrStringDictionary {
  [index: string]: number | string;
 
  length: number; // ok, length is a number
  name: string; // ok, name is a string
}
```

### T√≠nh nƒÉng index signatures readonly

Ta c≈©ng c√≥ th·ªÉ d√πng t√≠nh nƒÉng c·∫•m g√°n l·∫°i gi√° tr·ªã kh√°c - readonly cho t·∫•t c·∫£ c√°c index:

```ts
interface ReadonlyStringArray {
  readonly [index: number]: string;
}
 
let myArray: ReadonlyStringArray = ["Alice", "Bob"];
myArray[1] = "Mallory"; // error!
myArray[2] = "Mallory"; // error!
```

### S·ª≠ d·ª•ng v·ªõi ki·ªÉu string c√≥ d·∫°ng ƒë·∫∑c tr∆∞ng ri√™ng

```ts
interface HeadersResponse {
  "content-type": string,
  date: string,
  "content-length": string
 
  // Permit any property starting with 'data-'.
  [headerName: `x-${string}`]: string;
}
 
function handleResponse(r: HeadersResponse) {
  // Handle known, and x- prefixed
  const type = r["content-type"]
  const poweredBy = r["x-powered-by"]
 
  // Unknown keys without the prefix raise errors
  const origin = r.origin
  // Error: Property 'origin' does not exist on type 'HeadersResponse'.
}
```

Ki·ªÉu `HeadersResponse` cho ph√©p c√°c thu·ªôc t√≠nh c√≥ ch·ªØ c√°i ƒë·∫ßu l√† *x*, c√≤n *origin* property th√¨ kh√¥ng cho ph√©p.

## Tham kh·∫£o

- [typescript - handbook - indexable-types](https://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types)

---

Photo by <a href="https://unsplash.com/@joepohle?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Joe Pohle</a> on <a href="https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>
